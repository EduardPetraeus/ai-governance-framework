# MEMORY.md

Cross-session memory for AI agents working on this project. This file captures knowledge that is too specific for CLAUDE.md (which governs behavior) but too important to lose between sessions (which are ephemeral).

**How agents should use this file:**
- Read at session start, after CLAUDE.md and PROJECT_PLAN.md.
- Update at session end when something was learned that would prevent a mistake or save time in a future session.
- Do not add every detail. Only add knowledge that changed your approach or would prevent a future agent from making a mistake you made.

**Last updated:** YYYY-MM-DD (Session NNN)

---

## Project Facts

<!-- Immutable facts about the project. These do not change without an ADR.
     Agents must not suggest alternatives to these without flagging the
     existing decision first.
     CUSTOMIZE: Replace with your actual project facts. -->

- **Python version:** 3.11. Do not suggest upgrading without discussion -- pinned for Databricks/platform compatibility.
- **Database strategy:** DuckDB for local development and analytics pipeline. PostgreSQL for application state. They serve different purposes and are not interchangeable. See ADR-001.
- **SQL convention:** All pipeline SQL uses `MERGE INTO`, never `INSERT INTO`. This makes every stage idempotent. No exceptions.
- **Test data:** Generated by factories in `tests/fixtures/factories.py`. Never use real data from production or external APIs in tests. Never hardcode test data inline.
- **Base connector:** `src/connectors/base_connector.py` is the parent class for all connectors. Every connector must inherit from it. It handles auth, retry, rate limiting, and schema validation. No connector implements these independently.
- **Granularity:** All data sources use daily granularity in the silver layer. Not hourly, not raw. See ADR-002.

<!-- CUSTOMIZE: Add your own immutable project facts here. -->

---

## Confirmed Patterns

<!-- Patterns that have been validated to work well in THIS codebase.
     When building new features, follow these patterns rather than inventing
     alternatives. Each pattern includes where to find the reference implementation.
     CUSTOMIZE: Replace with patterns confirmed in your project. -->

- **Connector pattern:** New data sources follow `src/connectors/[source_name].py` inheriting `BaseConnector`. See `src/connectors/stripe.py` for the reference implementation. The pattern handles: auth setup in `__init__`, data fetch in `fetch_data()`, schema validation via `validate_schema()` before writing to bronze. Do not add retry logic to individual connectors -- the base class handles it.

- **MERGE INTO for all writes:** All pipeline stages use `MERGE INTO` (upsert), not `INSERT INTO`. This was established in Session 003 and confirmed working across all transforms. The pattern prevents duplicate rows when a pipeline stage is re-run and eliminates "did I already process this?" logic.

- **Test factories over static fixtures:** `tests/fixtures/factories.py` uses the factory pattern to generate test data. Factories produce realistic data that reflects current schema. Static fixtures (JSON/CSV files) break silently when the schema changes. Factories break loudly.

- **Environment variables for all configuration:** No hardcoded values in any configuration file. Locally: `.env` file (gitignored). In CI: GitHub Secrets. In production: secrets manager. The only place secret names (not values) appear is in `README.md` and `.env.example`.

- **Conventional commits:** All commit messages follow `type(scope): description`. Types: feat, fix, docs, refactor, test, chore, perf. Scope is optional but recommended for multi-module projects. Example: `feat(bronze): add Oura sleep connector`.

<!-- CUSTOMIZE: Add patterns confirmed in your project. Include the reference implementation. -->

---

## Anti-patterns Discovered

<!-- Things that were tried and abandoned, with specific reasons why.
     This prevents future sessions from re-discovering the same dead ends.
     CUSTOMIZE: Replace with anti-patterns discovered in your project. -->

- **Do not use `SELECT *` in transforms.** Session 004 discovered that `SELECT *` in silver transforms broke silently when a source API added a new field to its response. The bronze table grew a column that the silver transform did not expect, causing a type mismatch in downstream aggregation. Always list columns explicitly in transforms.

- **Do not modify `base_connector.py` without running all connector tests.** Session 007 changed the retry logic in the base class. The change looked safe. It broke 3 of 8 connectors because they relied on a specific retry timing for rate-limited APIs. Always run `pytest tests/integration/` before committing base class changes.

- **Do not write multi-layer changes in one session.** Session 005 attempted to change both the bronze schema and the silver transforms in one session. The changes were interdependent. A mistake in the bronze schema propagated silently to silver. It took two full sessions to untangle. One architectural layer per session.

- **Do not assume bronze layer schema is stable.** Source APIs change response format without warning. The Oura API added a `temperature_deviation` field in March 2026 that was not in the documentation. Always use `validate_schema()` on ingestion. Log unexpected fields as warnings, do not fail silently.

- **Do not cache API responses in the bronze layer.** Session 008 considered adding a caching layer for API responses to avoid hitting rate limits. The complexity of cache invalidation for irregularly-updating health data (some sources update daily, some update multiple times per day, some skip days) exceeded the benefit. The daily batch pipeline with rate limiting handles the volume without caching.

<!-- CUSTOMIZE: Add anti-patterns discovered in your project. Be specific about what happened. -->

---

## Open Decisions

<!-- Decisions that have not been made yet. Agents must not make unilateral
     progress on these. When an open decision comes up during a session,
     flag it and ask the user to decide.
     CUSTOMIZE: Replace with your actual open decisions. -->

- **Message queue for async processing:** Should the notification system use Redis Pub/Sub (simpler, already in the stack) or AWS SQS (managed, durable, scales)? Not decided. Do not implement either without a decision. Relevant to Phase 2 notification work. (Raised in Session 006)

- **Backfill strategy for new data sources:** When adding a new source, how many months of historical data should the first run fetch? Current practice is "as much as the API allows," but this creates large initial datasets that slow local development. Options: (a) full history, (b) last 90 days, (c) configurable per source. Not standardized. (Raised in Session 008)

- **Dashboard technology:** The gold layer has aggregated views but no visualization layer. Options considered: Streamlit (fast to build, Python-native), Grafana (operational dashboards, good with time series), custom React app (most flexible, most effort). No decision yet. (Raised in Session 010)

<!-- CUSTOMIZE: Add your open decisions. Move them to DECISIONS.md when resolved. -->

---

## Team Preferences

<!-- How this specific team or developer works with AI agents.
     These are not rules (those go in CLAUDE.md). They are preferences
     that make sessions smoother and output more useful.
     CUSTOMIZE: Replace with your team's actual working preferences. -->

- **Session length:** 1--2 hours. If a task is estimated at more than one session, decompose it before starting. Long sessions produce diminishing returns as context accumulates.

- **Verbosity:** Show full task reports after each task. Do not abbreviate, even if it feels repetitive. This team reads the reports to stay oriented.

- **Diffs before commits:** Always show the complete diff of changed files before committing. Do not auto-commit without the user seeing and approving the changes.

- **Uncertainty handling:** When uncertain about an implementation approach, present two options with trade-offs rather than picking one silently. The team prefers explicit decisions over implicit assumptions.

- **Documentation inline:** Update docstrings and inline comments when modifying functions. Do not defer documentation to a separate session -- it never happens.

- **PR size:** Small, focused PRs preferred. One feature or one fix per PR. PRs that change more than 10 files get pushed back for decomposition.

<!-- CUSTOMIZE: Document how your team prefers to work with AI agents. -->

---

## Session Notes

<!-- What agents have learned that is too ephemeral for the sections above
     but still useful for the next few sessions. Clean this section quarterly.
     CUSTOMIZE: Clear this section when starting your project. Agents populate it. -->

- The DuckDB connection pool must be explicitly closed after tests. Session 009 discovered that unclosed connections caused file lock errors in subsequent test runs. Added `connection.close()` to test teardown. Check for this pattern in new tests.

- The [Source API] returns pagination tokens that expire after 60 seconds. The current connector fetches all pages synchronously. This works for current volume (<500 records/day) but will need async pagination if volume grows above ~5000 records/day.

- The user reviews diffs carefully before approving commits. Do not rush. Show the full diff and wait for explicit approval.

<!-- CUSTOMIZE: Clear this section. Agents add their learnings here during sessions. -->
